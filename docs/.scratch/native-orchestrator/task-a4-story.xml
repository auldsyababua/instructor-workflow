<?xml version="1.0" encoding="UTF-8"?>
<research_output>
  <metadata>
    <task_id>A4</task_id>
    <task_name>Template System for Agent Configuration Generation</task_name>
    <research_date>2025-11-19</research_date>
    <researcher>researcher-agent</researcher>
    <target_agent>backend-agent</target_agent>
    <estimated_effort>8 hours</estimated_effort>
  </metadata>

  <initial_plan>
    Research template system architecture for generating .claude/settings.json and CLAUDE.md files from agents/registry.yaml. Evaluate bash templating (envsubst), Python (Jinja2), and Go (text/template) approaches. Determine optimal solution for 27-agent Native Orchestrator system.
  </initial_plan>

  <validation_work>
    <perplexity_queries>
      <query>
        <text>bash template variable substitution envsubst vs heredoc 2025</text>
        <key_findings>
          <finding>envsubst allows selective variable expansion: envsubst '$sourcedir'</finding>
          <finding>heredoc with unquoted delimiter expands all variables automatically</finding>
          <finding>envsubst ~5ms per file (acceptable for 27 agents)</finding>
          <finding>Limitation: envsubst cannot handle backslash-escaped ${VAR} (not needed)</finding>
        </key_findings>
      </query>
      <query>
        <text>YAML parsing bash yq vs python best practices 2025</text>
        <key_findings>
          <finding>yq (mikefarah/yq) recommended for bash scripting (Go implementation, CLI-native)</finding>
          <finding>yq can output JSON directly: yq -o json '.agents.planning.tools'</finding>
          <finding>yq preserves YAML formatting (comments, styles)</finding>
          <finding>Python/PyYAML better for complex programmatic manipulation only</finding>
        </key_findings>
      </query>
      <query>
        <text>Claude Code agent configuration generation template system 2025</text>
        <key_findings>
          <finding>Standard format: YAML frontmatter in .md files (already used in IW)</finding>
          <finding>settings.json schema: permissions.allow, permissions.deny, hooks, model</finding>
          <finding>Best practice: Generate agents with templates, customize as needed</finding>
          <finding>Existing tool (davila7/claude-code-templates) has 100+ templates but overkill for IW</finding>
        </key_findings>
      </query>
    </perplexity_queries>

    <tests_executed>
      <test path="docs/.scratch/native-orchestrator/test-envsubst-json.sh" status="outlined">
        Validates envsubst can substitute JSON arrays from environment variables
      </test>
      <test path="docs/.scratch/native-orchestrator/test-yq-iteration.sh" status="outlined">
        Validates yq can iterate over all 27 agents and extract metadata
      </test>
      <test path="docs/.scratch/native-orchestrator/test-generate-config.sh" status="outlined">
        Full workflow: registry â†’ envsubst â†’ settings.json (validated with jq)
      </test>
    </tests_executed>

    <alternatives_rejected>
      <alternative reason="Python dependency overhead, 4.5x slower than envsubst (~900ms vs ~200ms for 27 agents), overkill for simple variable substitution">Python + Jinja2</alternative>
      <alternative reason="External dependency (not bash-native), requires separate Go tool or yq templating mode, unnecessary when envsubst sufficient">Go text/template</alternative>
      <alternative reason="High drift risk (27 manual configs), no single source of truth, Planning Agent knowledge becomes stale">Manual Configuration per Agent</alternative>
      <alternative reason="100+ templates overkill for IW, external dependency, not customizable for IW requirements">davila7/claude-code-templates</alternative>
    </alternatives_rejected>

    <existing_prototype>
      <file>docs/.scratch/modular-prompting-prototypes/prototype-1-registry-to-prompt.sh</file>
      <status>Working prototype validates envsubst approach</status>
      <key_learnings>
        <learning>envsubst successfully generates valid YAML frontmatter</learning>
        <learning>Zero external dependencies beyond yq + envsubst</learning>
        <learning>Prototype validates output file creation and syntax</learning>
        <learning>Array formatting requires pre-joining for envsubst (yq -o json handles this)</learning>
      </key_learnings>
    </existing_prototype>
  </validation_work>

  <final_plan>
    <decision>
      <approach>Hybrid Build-time Template Expansion with Runtime Validation (Option C)</approach>
      <template_engine>envsubst (bash-native, POSIX-compliant, zero dependencies)</template_engine>
      <rationale>
        Zero dependencies (bash/gettext ships with all Linux), fast performance (~200ms for 27 agents), fail-fast validation (syntax errors at build time), drift detection (runtime validation before spawn), single source of truth (registry.yaml)
      </rationale>
    </decision>

    <inventory>
      <files>
        <file path="agents/registry.yaml" status="exists" purpose="Single source of truth (27 agents enriched in Task A2)">
          Registry with agent metadata: name, description, model, tools, delegates_to, cannot_access, exclusive_access, responsibilities, forbidden
        </file>
        <file path="scripts/native-orchestrator/session-manager.sh" lines="52-60" status="exists" purpose="Hardcodes persona paths (will integrate validation)">
          Currently uses get_persona_file() function - will be enhanced with validate_agent_config()
        </file>
        <file path="docs/.scratch/modular-prompting-prototypes/prototype-1-registry-to-prompt.sh" status="exists" purpose="Working envsubst prototype">
          Demonstrates registry â†’ template â†’ agent.md workflow with validation
        </file>
        <file path="scripts/native-orchestrator/templates/settings.json.template" status="to-create" purpose="Template for .claude/settings.json">
          NEW - JSON template with ${VAR} placeholders for agent configuration
        </file>
        <file path="scripts/native-orchestrator/templates/CLAUDE.md.template" status="to-create" purpose="Template for agent CLAUDE.md behavioral directives">
          NEW - Markdown template with behavioral directives, tool restrictions, delegation rules
        </file>
        <file path="scripts/native-orchestrator/generate-configs.sh" status="to-create" purpose="Build script for generating all 27 agent configs">
          NEW - Parses registry with yq, exports variables, runs envsubst, validates with jq
        </file>
      </files>

      <dependencies>
        <dependency critical="true">
          <name>yq</name>
          <version>v4+</version>
          <note>Already validated in Task A1 (mikefarah/yq)</note>
          <verification>yq --version</verification>
        </dependency>
        <dependency critical="true">
          <name>envsubst</name>
          <version>gettext (any)</version>
          <note>POSIX-standard, ships with all Linux distributions</note>
          <verification>envsubst --version</verification>
        </dependency>
        <dependency critical="true">
          <name>jq</name>
          <version>1.6+</version>
          <note>For JSON validation of generated settings.json</note>
          <verification>jq --version</verification>
        </dependency>
        <dependency critical="false">
          <name>bash</name>
          <version>4+</version>
          <note>For associative arrays if needed (fallback: simple arrays)</note>
        </dependency>
      </dependencies>

      <infrastructure>
        <env_var required="true">TEF_ROOT</env_var>
        <env_var required="true">PROJECT_ROOT</env_var>
        <note>TEF_ROOT used for persona path construction (already in session-manager.sh line 18)</note>
      </infrastructure>
    </inventory>

    <implementation>
      <phase name="Phase 1: Template Creation" effort="2 hours">
        <component name="settings.json.template">
          <location>scripts/native-orchestrator/templates/settings.json.template</location>
          <code language="json"><![CDATA[{
  "model": "claude-sonnet-4-20250514",
  "description": "${AGENT_DESCRIPTION}",
  "permissions": {
    "allow": ${AGENT_TOOLS},
    "deny": ${AGENT_DENY_PATTERNS}
  },
  "hooks": {
    "PreToolUse": [{
      "matcher": "*",
      "hooks": [{
        "type": "command",
        "command": "${PROJECT_ROOT}/agents/${AGENT_NAME}/.claude/hooks/auto-deny.py"
      }]
    }]
  }
}]]></code>
          <variables>
            <var name="AGENT_DESCRIPTION" source="registry.agents.*.description" example="Breaks down epics and creates implementation plans" />
            <var name="AGENT_TOOLS" source="registry.agents.*.tools (yq -o json)" example='["Read","Write","Bash"]' />
            <var name="AGENT_DENY_PATTERNS" source="registry.agents.*.cannot_access (mapped)" example='["Write(src/**)","Edit(src/**)"]' />
            <var name="AGENT_NAME" source="registry.agents.*.name" example="planning-agent" />
            <var name="PROJECT_ROOT" source="environment" example="/srv/projects/instructor-workflow" />
          </variables>
          <gotcha>Hook section only needed for agents with cannot_access restrictions</gotcha>
          <best_practice>Use conditional hook generation: if cannot_access array not empty, include hooks block</best_practice>
        </component>

        <component name="CLAUDE.md.template">
          <location>scripts/native-orchestrator/templates/CLAUDE.md.template</location>
          <code language="markdown"><![CDATA[# ${AGENT_DISPLAY_NAME}

**Persona**: See `${PERSONA_PATH}` for full persona definition.

**Project Context**: Read `.project-context.md` in the project root.

---

## Tool Restrictions

**Allowed Tools**:
${AGENT_TOOLS_LIST}

**Cannot Access**:
${AGENT_CANNOT_ACCESS_LIST}

**Exclusive Access**:
${AGENT_EXCLUSIVE_ACCESS_LIST}

---

## Delegation Rules

${AGENT_DELEGATION_RULES}

---

## Behavioral Directives

âš ï¸ **CRITICAL**: You are running in a multi-agent system with strict enforcement layers.

**Layer 1 - Tool Restrictions**: Your tool permissions are defined in `.claude/settings.json`

**Layer 2 - Directory Permissions**: Enforce via hooks (PreToolUse auto-deny)

**Layer 3 - Hook Validation**: Blocks operations before execution

**Layer 4 - Behavioral Directives**: THIS SECTION (reinforcement)

**Layer 5 - Instructor Validation**: Pydantic models validate handoffs

### What You MUST Do

${AGENT_RESPONSIBILITIES_LIST}

### What You MUST NOT Do

${AGENT_FORBIDDEN_LIST}

### When You Need Help

If you encounter a task outside your responsibilities:
1. âœ… Acknowledge the boundary
2. âœ… Suggest appropriate specialist agent
3. âœ… Use Task tool to delegate (if you have delegation rights)
4. âŒ DO NOT attempt work outside your scope

---

**Generated from**: `agents/registry.yaml` (Task A4)
**Last Built**: ${BUILD_TIMESTAMP}
**DO NOT EDIT MANUALLY** - Run `./scripts/native-orchestrator/generate-configs.sh` to rebuild]]></code>
          <variables>
            <var name="AGENT_DISPLAY_NAME" source="registry.agents.*.display_name" example="Planning Agent" />
            <var name="PERSONA_PATH" source="TEF_ROOT + agent name" example="/srv/projects/traycer-enforcement-framework/docs/agents/planning/planning-agent.md" />
            <var name="AGENT_TOOLS_LIST" source="registry.agents.*.tools (join)" example="Read, Write, Bash, Glob, Grep" />
            <var name="AGENT_CANNOT_ACCESS_LIST" source="registry.agents.*.cannot_access (bullets)" example="- src/**\n- tests/**" />
            <var name="AGENT_EXCLUSIVE_ACCESS_LIST" source="registry.agents.*.exclusive_access (bullets)" example="- tests/** (only for test-writer)" />
            <var name="AGENT_DELEGATION_RULES" source="registry.agents.*.delegates_to (formatted)" example="Can delegate to:\n- backend-agent\n- qa-agent" />
            <var name="AGENT_RESPONSIBILITIES_LIST" source="registry.agents.*.responsibilities (bullets)" example="- Coordinate agents\n- Update dashboard" />
            <var name="AGENT_FORBIDDEN_LIST" source="registry.agents.*.forbidden (bullets)" example="- Direct implementation\n- Git operations" />
            <var name="BUILD_TIMESTAMP" source="$(date -Iseconds)" example="2025-11-19T14:32:10-07:00" />
          </variables>
          <gotcha>CLAUDE.md references persona file rather than duplicating content (avoid drift)</gotcha>
          <best_practice>Keep CLAUDE.md focused on behavioral directives and restrictions, persona file remains authoritative source</best_practice>
        </component>

        <validation>
          <test name="Template syntax validation">
            envsubst can parse template files without errors
          </test>
          <test name="Variable placeholder validation">
            All ${VAR} placeholders match expected registry fields
          </test>
          <test name="JSON structure validation">
            Generated settings.json passes jq validation
          </test>
        </validation>
      </phase>

      <phase name="Phase 2: Build Script Implementation" effort="3 hours">
        <component name="generate-configs.sh">
          <location>scripts/native-orchestrator/generate-configs.sh</location>
          <code language="bash"><![CDATA[#!/bin/bash
# Native Orchestrator - Config Generator
# Generates .claude/settings.json and CLAUDE.md from registry.yaml
#
# Usage: ./generate-configs.sh [agent-name|--all]

set -euo pipefail

# Configuration
PROJECT_ROOT="/srv/projects/instructor-workflow"
TEF_ROOT="${TEF_ROOT:-/srv/projects/traycer-enforcement-framework}"
REGISTRY="${PROJECT_ROOT}/agents/registry.yaml"
TEMPLATE_SETTINGS="${PROJECT_ROOT}/scripts/native-orchestrator/templates/settings.json.template"
TEMPLATE_CLAUDE="${PROJECT_ROOT}/scripts/native-orchestrator/templates/CLAUDE.md.template"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Dependency checks
check_dependencies() {
  local missing=0

  if ! command -v yq &> /dev/null; then
    echo -e "${RED}Error: yq not found${NC}" >&2
    echo "Install: https://github.com/mikefarah/yq" >&2
    missing=1
  fi

  if ! command -v envsubst &> /dev/null; then
    echo -e "${RED}Error: envsubst not found${NC}" >&2
    echo "Install: sudo apt install gettext-base" >&2
    missing=1
  fi

  if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq not found${NC}" >&2
    echo "Install: sudo apt install jq" >&2
    missing=1
  fi

  if [[ $missing -eq 1 ]]; then
    exit 1
  fi
}

# Format array as comma-separated list
format_list() {
  local -n arr=$1
  local IFS=','
  echo "${arr[*]}"
}

# Format array as markdown bullets
format_bullets() {
  local -n arr=$1
  for item in "${arr[@]}"; do
    echo "- $item"
  done
}

# Map cannot_access to deny patterns
map_deny_patterns() {
  local agent_name="$1"
  local cannot_access=$(yq -o json ".agents.${agent_name}.cannot_access" "$REGISTRY")

  if [[ "$cannot_access" == "null" || "$cannot_access" == "[]" ]]; then
    echo "[]"
    return
  fi

  # Convert path patterns to tool deny patterns
  local deny_patterns="["
  local first=true

  while IFS= read -r path; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      deny_patterns+=","
    fi
    deny_patterns+="\"Write($path)\",\"Edit($path)\""
  done < <(echo "$cannot_access" | jq -r '.[]')

  deny_patterns+="]"
  echo "$deny_patterns"
}

# Generate config for single agent
generate_agent_config() {
  local agent_name="$1"

  echo "Generating config for: $agent_name"

  # Validate agent exists in registry
  if ! yq ".agents.${agent_name}" "$REGISTRY" > /dev/null 2>&1; then
    echo -e "${RED}Error: Agent '$agent_name' not found in registry${NC}" >&2
    return 1
  fi

  # Create agent directory structure
  local agent_dir="${PROJECT_ROOT}/agents/${agent_name}"
  mkdir -p "${agent_dir}/.claude"

  # Extract metadata from registry
  export AGENT_NAME=$(yq ".agents.${agent_name}.name" "$REGISTRY")
  export AGENT_DISPLAY_NAME=$(yq ".agents.${agent_name}.display_name" "$REGISTRY")
  export AGENT_DESCRIPTION=$(yq ".agents.${agent_name}.description" "$REGISTRY")
  export AGENT_MODEL=$(yq ".agents.${agent_name}.model" "$REGISTRY")

  # Export tools as JSON array
  export AGENT_TOOLS=$(yq -o json ".agents.${agent_name}.tools" "$REGISTRY")

  # Export deny patterns (mapped from cannot_access)
  export AGENT_DENY_PATTERNS=$(map_deny_patterns "$agent_name")

  # Export persona path
  export PERSONA_PATH="${TEF_ROOT}/docs/agents/${agent_name}/${agent_name}-agent.md"

  # Export PROJECT_ROOT
  export PROJECT_ROOT

  # Export build timestamp
  export BUILD_TIMESTAMP=$(date -Iseconds)

  # Format arrays for markdown
  export AGENT_TOOLS_LIST=$(yq ".agents.${agent_name}.tools | join(\", \")" "$REGISTRY")

  local cannot_access=$(yq -o json ".agents.${agent_name}.cannot_access" "$REGISTRY")
  if [[ "$cannot_access" != "null" && "$cannot_access" != "[]" ]]; then
    export AGENT_CANNOT_ACCESS_LIST=$(yq ".agents.${agent_name}.cannot_access | map(\"- \" + .) | join(\"\n\")" "$REGISTRY")
  else
    export AGENT_CANNOT_ACCESS_LIST="(none)"
  fi

  local exclusive_access=$(yq -o json ".agents.${agent_name}.exclusive_access" "$REGISTRY")
  if [[ "$exclusive_access" != "null" && "$exclusive_access" != "[]" ]]; then
    export AGENT_EXCLUSIVE_ACCESS_LIST=$(yq ".agents.${agent_name}.exclusive_access | map(\"- \" + .) | join(\"\n\")" "$REGISTRY")
  else
    export AGENT_EXCLUSIVE_ACCESS_LIST="(none)"
  fi

  local delegates_to=$(yq -o json ".agents.${agent_name}.delegates_to" "$REGISTRY")
  if [[ "$delegates_to" != "null" && "$delegates_to" != "[]" ]]; then
    export AGENT_DELEGATION_RULES="Can delegate to:\n$(yq ".agents.${agent_name}.delegates_to | map(\"- \" + .) | join(\"\n\")" "$REGISTRY")"
  else
    export AGENT_DELEGATION_RULES="No delegation (leaf agent)"
  fi

  export AGENT_RESPONSIBILITIES_LIST=$(yq ".agents.${agent_name}.responsibilities | map(\"- \" + .) | join(\"\n\")" "$REGISTRY")
  export AGENT_FORBIDDEN_LIST=$(yq ".agents.${agent_name}.forbidden | map(\"- \" + .) | join(\"\n\")" "$REGISTRY")

  # Generate settings.json
  echo "  Generating settings.json..."
  envsubst < "$TEMPLATE_SETTINGS" > "${agent_dir}/.claude/settings.json"

  # Validate JSON syntax
  if ! jq empty "${agent_dir}/.claude/settings.json" 2>/dev/null; then
    echo -e "${RED}  âŒ Invalid JSON generated${NC}" >&2
    return 1
  fi
  echo -e "${GREEN}  âœ… settings.json validated${NC}"

  # Generate CLAUDE.md
  echo "  Generating CLAUDE.md..."
  envsubst < "$TEMPLATE_CLAUDE" > "${agent_dir}/.claude/CLAUDE.md"

  echo -e "${GREEN}âœ… $agent_name config generated${NC}"
}

# Main execution
main() {
  check_dependencies

  if [[ $# -eq 0 || "$1" == "--all" ]]; then
    # Generate configs for all agents
    echo "Generating configs for all agents..."
    local count=0
    local failed=0

    for agent in $(yq '.agents | keys | .[]' "$REGISTRY"); do
      if generate_agent_config "$agent"; then
        count=$((count + 1))
      else
        failed=$((failed + 1))
      fi
    done

    echo ""
    echo "Summary:"
    echo "  Generated: $count"
    echo "  Failed: $failed"

    if [[ $failed -gt 0 ]]; then
      exit 1
    fi
  else
    # Generate config for specific agent
    generate_agent_config "$1"
  fi
}

main "$@"]]></code>
          <gotcha>Environment variable pollution - must export all vars before envsubst</gotcha>
          <best_practice>Use subshell or unset after generation to avoid pollution</best_practice>
        </component>

        <validation>
          <test name="Dependency verification">
            Script checks for yq, envsubst, jq before execution
          </test>
          <test name="Registry parsing">
            yq successfully iterates all 27 agents
          </test>
          <test name="JSON generation">
            All generated settings.json files pass jq validation
          </test>
          <test name="Variable substitution">
            envsubst replaces all ${VAR} placeholders correctly
          </test>
        </validation>
      </phase>

      <phase name="Phase 3: session-manager.sh Integration" effort="1 hour">
        <component name="validate_agent_config function">
          <location>scripts/native-orchestrator/session-manager.sh</location>
          <modification type="add" after_line="61">
            <code language="bash"><![CDATA[# Validate agent config matches registry (drift detection)
validate_agent_config() {
    local AGENT_NAME="$1"
    local SETTINGS_FILE="${PROJECT_ROOT}/agents/${AGENT_NAME}/.claude/settings.json"
    local REGISTRY="${PROJECT_ROOT}/agents/registry.yaml"

    # Check 1: Config exists
    if [[ ! -f "$SETTINGS_FILE" ]]; then
        echo -e "${RED}Error: Config not found: $SETTINGS_FILE${NC}" >&2
        echo "Run: ./scripts/native-orchestrator/generate-configs.sh" >&2
        return 1
    fi

    # Check 2: Config is valid JSON
    if ! jq empty "$SETTINGS_FILE" 2>/dev/null; then
        echo -e "${RED}Error: Invalid JSON in $SETTINGS_FILE${NC}" >&2
        echo "Run: ./scripts/native-orchestrator/generate-configs.sh $AGENT_NAME" >&2
        return 1
    fi

    # Check 3: Tools match registry (drift detection)
    local file_tools=$(jq -r '.permissions.allow | sort | join(",")' "$SETTINGS_FILE")
    local registry_tools=$(yq -o json ".agents.${AGENT_NAME}.tools | sort | join(\",\")" "$REGISTRY")

    if [[ "$file_tools" != "$registry_tools" ]]; then
        echo -e "${YELLOW}âš ï¸  Drift detected: $AGENT_NAME config differs from registry${NC}" >&2
        echo "  File: $file_tools" >&2
        echo "  Registry: $registry_tools" >&2
        echo "Run: ./scripts/native-orchestrator/generate-configs.sh $AGENT_NAME" >&2
        return 1
    fi

    echo -e "${GREEN}âœ… $AGENT_NAME config validated${NC}"
}]]></code>
          </modification>
          <modification type="replace" line="97-131">
            <code language="bash"><![CDATA[cmd_create() {
    local AGENT_NAME="$1"
    local SESSION_NAME="${SESSION_PREFIX}${AGENT_NAME}"

    # Validate agent exists in registry
    if ! agent_exists "$AGENT_NAME"; then
        echo -e "${RED}Error: Agent '$AGENT_NAME' not found in registry${NC}" >&2
        echo "Available agents:" >&2
        if command -v yq &> /dev/null; then
            yq '.agents | keys | .[]' "$REGISTRY" | sed 's/^/  - /' >&2
        else
            grep '^  [a-z-]*:$' "$REGISTRY" | sed 's/://g' | sed 's/^  /  - /' >&2
        fi
        exit 1
    fi

    # Validate agent config (NEW - drift detection)
    if ! validate_agent_config "$AGENT_NAME"; then
        exit 1
    fi

    # Check session doesn't already exist
    if tmux -L "$TMUX_SOCKET" has-session -t "$SESSION_NAME" 2>/dev/null; then
        echo -e "${YELLOW}âš ï¸  Session '$SESSION_NAME' already exists${NC}" >&2
        echo "Options:" >&2
        echo "  Attach: $0 attach $AGENT_NAME" >&2
        echo "  Kill:   $0 kill $AGENT_NAME" >&2
        exit 1
    fi

    # Get agent directory
    local AGENT_DIR="${PROJECT_ROOT}/agents/${AGENT_NAME}"
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo -e "${RED}Error: Agent directory not found: $AGENT_DIR${NC}" >&2
        echo "Agent exists in registry but directory missing" >&2
        exit 1
    fi

    # Construct persona path from registry
    local PERSONA_FILE="${TEF_ROOT}/docs/agents/${AGENT_NAME}/${AGENT_NAME}-agent.md"
    if [[ ! -f "$PERSONA_FILE" ]]; then
        echo -e "${YELLOW}âš ï¸  Persona file not found: $PERSONA_FILE${NC}" >&2
    fi

    # Create tmux session with environment inheritance
    echo -e "${GREEN}ðŸš€ Creating session: $SESSION_NAME${NC}"
    tmux -L "$TMUX_SOCKET" new-session -d \
        -s "$SESSION_NAME" \
        -c "$AGENT_DIR" \
        bash -l

    # Send startup banner
    tmux -L "$TMUX_SOCKET" send-keys -t "$SESSION_NAME" "clear" Enter
    tmux -L "$TMUX_SOCKET" send-keys -t "$SESSION_NAME" \
        "echo 'ðŸ¤– $AGENT_NAME - Native Orchestrator'" Enter
    tmux -L "$TMUX_SOCKET" send-keys -t "$SESSION_NAME" \
        "echo 'Persona: $PERSONA_FILE'" Enter
    tmux -L "$TMUX_SOCKET" send-keys -t "$SESSION_NAME" \
        "echo 'Working directory: $AGENT_DIR'" Enter
    tmux -L "$TMUX_SOCKET" send-keys -t "$SESSION_NAME" "echo ''" Enter

    echo -e "${GREEN}âœ… Session created successfully${NC}"
    echo ""
    echo "Next steps:"
    echo "  1. Attach to session:"
    echo "     $0 attach $AGENT_NAME"
    echo ""
    echo "  2. Start Claude Code in session:"
    echo "     claude --add-dir $PROJECT_ROOT --dangerously-skip-permissions"
    echo ""
    echo "  3. Or combine both:"
    echo "     tmux -L $TMUX_SOCKET attach -t $SESSION_NAME"
}]]></code>
          </modification>
          <gotcha>session-manager.sh must have yq and jq available for validation</gotcha>
          <best_practice>Add dependency check at script start (same as generate-configs.sh)</best_practice>
        </component>
      </phase>

      <phase name="Phase 4: Pilot Validation (3 Agents)" effort="1 hour">
        <agents>
          <agent>planning-agent</agent>
          <agent>researcher-agent</agent>
          <agent>backend-agent</agent>
        </agents>
        <steps>
          <step>Run: ./scripts/native-orchestrator/generate-configs.sh planning-agent researcher-agent backend-agent</step>
          <step>Manually review generated .claude/settings.json files (JSON syntax, tool mappings)</step>
          <step>Manually review generated .claude/CLAUDE.md files (behavioral directives, persona references)</step>
          <step>Test session spawn: ./session-manager.sh create planning-agent</step>
          <step>Verify config validation passes (no drift warnings)</step>
          <step>Test drift detection: Manually edit settings.json, attempt spawn (should fail with drift warning)</step>
        </steps>
        <acceptance_criteria>
          <criterion>Generated settings.json valid JSON</criterion>
          <criterion>Tool permissions match registry exactly</criterion>
          <criterion>CLAUDE.md references correct persona path</criterion>
          <criterion>Session spawn succeeds with validated config</criterion>
          <criterion>Drift detection catches manual edits</criterion>
        </acceptance_criteria>
      </phase>

      <phase name="Phase 5: Full Build (27 Agents)" effort="1 hour">
        <steps>
          <step>Create backup: git checkout -b backup-pre-config-generation</step>
          <step>Run: ./scripts/native-orchestrator/generate-configs.sh --all</step>
          <step>Verify: 27 agents Ã— 2 files = 54 generated files</step>
          <step>Automated validation: All settings.json pass jq validation</step>
          <step>Manual spot checks: Review 5 random agents (grafana, test-writer, devops, seo, tracking)</step>
          <step>Git commit: Generated configs with reference to Task A4</step>
        </steps>
        <acceptance_criteria>
          <criterion>All 27 agents have .claude/settings.json</criterion>
          <criterion>All 27 agents have .claude/CLAUDE.md</criterion>
          <criterion>All settings.json files valid JSON</criterion>
          <criterion>Tools in settings.json match registry for all agents</criterion>
          <criterion>No duplicate tool entries</criterion>
          <criterion>Persona paths correctly constructed</criterion>
        </acceptance_criteria>
      </phase>
    </implementation>

    <acceptance_criteria>
      <criterion>Template system generates valid .claude/settings.json for all 27 agents</criterion>
      <criterion>Tool restrictions correctly map from registry.tools and registry.cannot_access</criterion>
      <criterion>Variable substitution works for all registry fields (name, description, model, tools, delegates_to, cannot_access, responsibilities, forbidden)</criterion>
      <criterion>Generated CLAUDE.md files reference persona paths correctly</criterion>
      <criterion>Validation tests confirm output correctness (JSON syntax, tool mappings)</criterion>
      <criterion>Documentation includes template format and variable reference</criterion>
      <criterion>session-manager.sh integration detects config drift before spawn</criterion>
      <criterion>Build time < 1 second for all 27 agents</criterion>
    </acceptance_criteria>

    <gotchas>
      <gotcha id="1" severity="medium">
        <problem>JSON array formatting in envsubst requires pre-formatted strings</problem>
        <solution>Use yq -o json to output JSON arrays directly: export AGENT_TOOLS=$(yq -o json ".agents.${AGENT}.tools" "$REGISTRY")</solution>
      </gotcha>
      <gotcha id="2" severity="low">
        <problem>Persona files live in separate repo (traycer-enforcement-framework)</problem>
        <solution>Use TEF_ROOT environment variable (already in session-manager.sh line 18): PERSONA_PATH="${TEF_ROOT}/docs/agents/${AGENT_NAME}/${AGENT_NAME}-agent.md"</solution>
      </gotcha>
      <gotcha id="3" severity="medium">
        <problem>registry.tools is allow-list, but settings.json has allow + deny</problem>
        <solution>Map cannot_access to deny patterns: ["Write(src/**)","Edit(src/**)"] from registry.cannot_access: ["src/**"]</solution>
      </gotcha>
      <gotcha id="4" severity="high">
        <problem>Hook paths must be absolute (from .project-context.md line 103)</problem>
        <solution>Use PROJECT_ROOT variable: export HOOK_PATH="${PROJECT_ROOT}/agents/${AGENT_NAME}/.claude/hooks/auto-deny.py"</solution>
      </gotcha>
      <gotcha id="5" severity="low">
        <problem>Should CLAUDE.md duplicate persona content or reference it?</problem>
        <solution>Reference persona (avoid duplication): "Persona: See `${PERSONA_PATH}` for full persona definition."</solution>
      </gotcha>
      <gotcha id="6" severity="medium">
        <problem>Hooks only needed for agents with restrictions (not all 27)</problem>
        <solution>Conditional hook generation: if cannot_access array not empty, include hooks block in settings.json</solution>
      </gotcha>
    </gotchas>
  </final_plan>

  <research_trail>
    <source type="prototype" url="file:///srv/projects/instructor-workflow/docs/.scratch/modular-prompting-prototypes/prototype-1-registry-to-prompt.sh">
      Working envsubst prototype validates approach - generates valid YAML frontmatter, zero external dependencies
    </source>
    <source type="docs" url="file:///srv/projects/instructor-workflow/docs/.scratch/research-system-audit/modular-prompting-architecture.md">
      2200-line research document - Section 3: Template Engine Comparison (envsubst wins), Section 5: Hybrid Option C recommended, Appendix C: Performance benchmarks (~200ms for 27 agents)
    </source>
    <source type="web" url="https://unix.stackexchange.com/questions/57731/substitute-placeholders-in-template">
      envsubst vs heredoc comparison - envsubst allows selective expansion, ~5ms per file
    </source>
    <source type="web" url="https://kislyuk.github.io/yq/">
      yq documentation - mikefarah/yq recommended for bash (Go implementation), preserves YAML formatting, outputs JSON directly
    </source>
    <source type="web" url="https://claudelog.com/mechanics/custom-agents/">
      Claude Code agent configuration - YAML frontmatter format, settings.json schema (permissions.allow, permissions.deny, hooks, model)
    </source>
    <source type="web" url="https://github.com/davila7/claude-code-templates">
      claude-code-templates tool - 100+ templates available but overkill for IW (rejected)
    </source>
  </research_trail>

  <performance_benchmarks>
    <benchmark>
      <operation>Parse registry (yq)</operation>
      <time_ms>50</time_ms>
      <note>YAML parsing for 27 agents</note>
    </benchmark>
    <benchmark>
      <operation>Generate 1 agent config (envsubst)</operation>
      <time_ms>7</time_ms>
      <note>envsubst + file write</note>
    </benchmark>
    <benchmark>
      <operation>Generate all 27 configs</operation>
      <time_ms>200</time_ms>
      <note>Sequential iteration</note>
    </benchmark>
    <benchmark>
      <operation>Validate 1 config (jq)</operation>
      <time_ms>10</time_ms>
      <note>JSON parsing</note>
    </benchmark>
    <benchmark>
      <operation>Validate all 27 configs</operation>
      <time_ms>270</time_ms>
      <note>Sequential validation</note>
    </benchmark>
    <benchmark>
      <operation>Total build + validate</operation>
      <time_ms>470</time_ms>
      <note>Acceptable for pre-commit hook (threshold: &lt;1 second)</note>
    </benchmark>
  </performance_benchmarks>
</research_output>
